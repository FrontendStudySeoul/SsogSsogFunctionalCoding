# 타임라인 격리하기
>
> 시간에 따라 실행되는 액션의 순서를 나타내기 위해 타임라인 다이어그램에 대해 알아보기

## 타임라인 다이어그램은 시간에 따라 어떤 일이 일어나는지 보여줍니다

****
> 타임라인은 액션을 순서대로 나열한 것, 타임라인 다이어그램은 시간에 따른 액션 순서를 시각적으로 표시한 것.

## 두 가지 타임라인 다이어그램 기본 규칙

순서대로 실행되는 액션, 동시에 나란히 실행되는 액션 두 가지가 중요한 사실. 두 종류의 액션을 시각화해 보면 코드가 올바르게 동작하는지 아니면 문제가 있는지 알 수 있음.

### 규칙

1. 두 액션이 순서대로 나타나면 같은 타임라인에 넣는다.
2. 두 액션이 동시에 실행되거나 순서를 예상할 수 없다면 분리된 타임라인에 넣는다.

- 서로 다른 스레드, 프로세스, 기계, 비동기 콜백에서 실행되면 서로 다른 타임라인에 표시 -> 액션 두 개가 서로 다른 비동기 콜백에서 실행됨.

### 요약

1. 액션은 순서대로 실행되거나 동시에 실행된다.
2. 순서대로 실행되는 액션은 같은 타임라인에서 하나가 끝나면 다른 하나가 실행된다.
3. 동시에 실행되는 액션은 여러 타임라인에서 나란히 실행된다.

## 타임라인 그리기: 단계 1

<img width="822" alt="스크린샷 2023-10-25 오후 10 49 45" src="https://github.com/kingyong9169/kingyong9169/assets/62797441/df627241-0aa2-451f-9cf2-63b1f3e63de2">

1. 액션을 확인
2. 순서대로 실행되거나 동시에 실행되는 액션 그리기
3. 플랫폼에 특화된 지식을 사용해 다이어그램 단순화 하기

## 비동기 호출은 새로운 타임라인으로 그리기

1. 액션 확인
<img width="799" alt="스크린샷 2023-10-25 오후 10 50 20" src="https://github.com/kingyong9169/kingyong9169/assets/62797441/e0615eba-0ec5-4168-9947-c503f4d3c759">

2. 액션 그리기
<img width="788" alt="스크린샷 2023-10-25 오후 11 12 22" src="https://github.com/kingyong9169/kingyong9169/assets/62797441/5a8f1832-13d1-48d2-938d-a2f7e11f9f8b">

- 콜백은 언제 실행될지 예측할 수 없기에 다른 타임라인으로 분리

## 서로 다른 언어, 서로 다른 스레드 모델

### 단일 스레드, 동기

php는 기본적으로 멀티스레드 지원 x, 모든 것이 순서대로 실행되고 입출력을 사용하면 끝날 때까지 기다려야 한다. 하지만 이런 제약은 시스템이 단순하다는 장점이기도 하다. 스레드가 하나면 타임라인도 하나이지만, 네트워크를 통한 API 호출 등 다른 타임라인도 필요하다. 하지만 메모리를 공유하지 않기 때문에 공유 자원을 많이 없앨 수 있다.

### 단일 스레드, 비동기

js는 단일 스레드. 입출력 작업을 하려면 비동기 모델을 사용해야 한다. 입출력의 결과는 콜백으로 받을 수 있지만, 언제 끝날지 알 수 없기 때문에 다른 타임라인에 표현해야 함.

### 멀티스레드

java, python, ruby, c, c#이 있음. 실행 순서를 보장하지 않기 때문에 프로그래밍하기 매우 어려움. 새로운 스레드가 생기면 새로운 타임라인을 그려야 함.

### 메시지 패싱 프로세스

엘릭서, 얼랭 같은 언어는 서로 다른 프로세스를 동시에 실행할 수 있는 스레드 모델을 지원. 프로세스는 서로 메모리를 공유하지 않고 메시지로 통신. 서로 다른 타임라인에 있는 액션은 순서가 섞이지만, 메모리를 공유하지 않기 때문에 가능한 실행 순서가 많아도 문제되지 않음.

## 타임라인 다이어그램으로 순서대로 실행되는 코드에도 두 가지 종류가 있다는 것을 알 수 있다

<img width="535" alt="스크린샷 2023-10-25 오후 11 09 11" src="https://github.com/kingyong9169/kingyong9169/assets/62797441/a47d2eb8-81ce-44c6-b597-feeb7ee96cc4">

### 순서가 섞일 수 있는 코드

- 두 액션 사이에 시간은 얼마나 걸릴지 알 수 없다.
- 액션은 박스, 액션 사이에 걸리는 시간은 선으로 표시
- 액션과 액션 사이에 걸리는 시간에 따라 선을 길게 혹은 짧게 그릴 수 있음.
- 그렇다고 해도 두 액션 간 시간이 얼마나 걸릴지 알 수 없다.

### 순서가 섞이지 않는 코드

어떤 경우에는 두 액션이 차레로 실행되는데 그 사이에 다른 작업이 끼어들지 못한다.

- 하나의 상자에 두 액션을 넣는다.

## 좋은 타임라인의 원칙
>
> 타임라인을 사용하면서 좋은 타임라인의 원칙을 알면 코드를 개선하거나 더 이해하기 쉬운 코드를 만드는 데 도움이 된다. 실행 가능한 순서가 많다면 시스템을 이해하기 어렵다는 것을 잊지말 것.

1. 타임라인은 적을수록 이해하기 쉽다.
2. 타임라인은 짧을수록 이해하기 쉽다. -> 타임라인의 단계를 줄이는 것.
3. 공유하는 자원이 적을수록 이해하기 쉽다. -> 신경써야 할 실행 가능한 순서를 줄일 수 있다.
4. 자원을 공유한다면 서로 조율해야 한다. -> 안전하게 공유할 수 있어야 한다.(올바른 순서대로 자원을 쓰고 돌려준다.)
5. 시간을 일급으로 다룬다. -> 타임라인 다루는 재사용 가능한 객체를 만들면 타이밍 문제를 쉽게 만들 수 있다.

## JS의 단일 스레드

JS의 스레드 모델은 타임라인이 자원을 공유하면서 생기는 문제를 줄여준다. 하나의 메인 스레드만 있어서 대부분의 액션을 하나의 박스로 표현할 수 있다.

비동기 콜백을 함께 사용한다면 문제가 생길 수 있다. 비동기 호출은 미래에 알 수 없는 시점에 런타임에 의해 실행된다. 따라서 박스 사이의 선이 길어질 수도 짧아질 수도 있다. **JS에서 어떤 동작이 동기인지 비동기인지 아는 것이 중요하다.**

## JS의 비동기 큐

브라우저에서 동작하는 JS 엔진은 **작업 큐**라고 하는 큐를 가지고 있다. 작업 큐는 **이벤트 루프**에 의해 처리된다. 이벤트 루프는 큐에서 작업 하나를 꺼내 실행하고 완료되면 다음 작업을 꺼내 실행하는 것을 무한히 반복한다. 하나의 스레드에서 처리하기 때문에 두 개의 작업이 동시에 실행될 수 없다.

### 작업

이벤트 데이터와 이벤트를 처리할 콜백으로 구성되어 있다.

### 작업은 큐에 어떻게 들어가나요?

이벤트(마우스 클릭, 키보드 입력, AJAX 호출)가 발생하면 큐에 작업이 추가된다. **예측 불가능한 시점**에 작업 큐에 들어간다.

### 작업이 없을 때 엔진은 무엇을 하나요?

처리할 작업이 없을 때, 대기 상태로 들어가고 전원을 아낀다. GC작업을 하기도 한다. 하지만 이는 브라우저 개발자에게 달려 있다.

## 타임라인 단순화하기

1. 하나의 타임라인에 있는 모든 액션을 하나로 통합
2. 타임라인이 끝나는 곳에서 새로운 타임라인이 하나만 생긴다면 통합

<img width="820" alt="스크린샷 2023-10-26 오전 1 51 57 1" src="https://github.com/kingyong9169/kingyong9169/assets/62797441/0f4b33ac-b4cd-4954-a39d-7182828cc472">

첫 번째 타임라인이 끝나는 곳에 새로운 타임라인이 두 개 생기기 때문에 통합하지 않는다.

## 완성된 타임라인 읽기

타임라인 다이어그램으로 가능한 액션의 순서를 알 수 있다. 실행 순서를 이해하면 코드가 제대로 동작하는지 알 수 있다. 잘 동작하지 않는 실행 순서를 알면 버그를 찾을 수 있고, 잘 동작하는 순서를 알면 코드가 올바르다는 것을 알 수 있다.

## 타임라인 단순화하기: 단계 3

### 1. 하나의 타임라인에 있는 모든 액션을 하나로 통합한다

JS는 하나의 스레드에서 모든 코드를 실행한다. 현재 타임라인에 다른 스레드가 끼어들지 않는다. 따라서 타임라인에 있는 액션이 서로 섞일 가능성이 없다.

<img width="209" alt="스크린샷 2023-10-28 오후 4 09 17" src="https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/assets/62797441/2f7eeb70-1baa-4093-baf8-e66df06abd6b">

<img width="603" alt="스크린샷 2023-10-28 오후 4 09 10" src="https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/assets/62797441/d48fd825-6c08-413e-aa24-a5df3e771ac6">

### 2. 타임라인이 끝나는 곳에서 새로운 타임라인이 하나 생긴다면 통합한다

다이어그램에 있는 타임라인은 새로운 타임라인이 시작하면 끝난다. 각 타임라인은 ajax 호출을 하면서 끝나고 콜백 하나가 다음 작업을 이어서 한다. 따라서 모든 타임라인을 하나의 타임라인으로 합칠 수 있다.

#### 타임라인을 쉽게 만드는 네 가지 원칙

1. 적은 타임라인
2. 짧은 타임라인
3. 적은 공유 자원
4. 자원을 공유한다면 조율하기

JS는 하나의 스레드에서 실행되기 때문에 모든 액션을 박스 하나에 넣을 수 있다. 다음으로 비동기 액션 이후에 연속되는 콜백이 하나라면 하나의 타임라인으로 통합할 수 있다. 완성된 다이어그램에 박스가 여러 개 남아 있다는 것을 보고 불확실한 타이밍과 순서가 섞일 가능성이 있다는 것을 알 수 있다.

JS 스레드 모델에서는 타임라인 세 개를 하나로 줄이고 단계도 13개에서 3개로 줄일 수 있다.

<img width="186" alt="스크린샷 2023-10-28 오후 4 18 20" src="https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/assets/62797441/f0a2865e-0678-42b1-9a43-3a6840a4a274">

이 상태에서 타임라인을 단순화하는 첫 번째 단계를 다시 적용해 모든 액션을 하나의 박스로 넣을 수는 없다. 그냥 이대로 둬야 한다. 만약 다른 타임라인에 액션이 생긴다면 각 박스는 순서가 섞일 가능성이 있기 때문이다.

이렇게 표현하면 콜백 체인이 하나의 타임라인에서 실행되는 것처럼 생각할 수 있다. 또한 그리기도 더 쉽다.

하지만 다이어그램으로 문제를 완전히 없앨 수 없다는 것도 알 수 있다. 비동기 액션은 여전히 분리된 박스로 표현한다.

## 타임라인을 나란히 보면 문제가 보인다

<img width="289" alt="스크린샷 2023-10-28 오후 4 28 02" src="https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/assets/62797441/cf7aa8b2-dbc3-4ab4-ae3b-bf9681966215">

장바구니에 제품을 담기 위해 두 번 빠르게 클릭하면 버그가 발생한다. 문제를 확인하기 위해 같은 타임라인을 나란히 놓고 본다.

다이어그램 하나는 하나의 클릭을 의미한다. 다른 타임라인에 있고 박스는 떨어져 있기 때문에 순서가 섞일 수 있다.

타임라인에 있는 단계들은 이벤트 큐가 순서대로 처리하는 것을 보장한다. 따라서 다이어그램을 조금 조정해볼 수 있다. 두 번째 타임라인은 첫 번째 타임라인에 있는 첫 번째 단계가 끝나야 실행되기 때문에 점선을 추가해서 실행 시점을 조정해 본다.

<img width="524" alt="스크린샷 2023-10-28 오후 4 30 16" src="https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/assets/62797441/5d65563b-eb67-4c30-9cab-1d1510ac6950">

문제가 없어 보이지만 사실 이 다이어그램은 많은 문제를 보여주고 있다.

## 두 번 천천히 클릭하면 문제가 없다

<img width="628" alt="스크린샷 2023-10-28 오후 4 31 42" src="https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/assets/62797441/c0bbdf47-c389-436b-a3bc-bec1f93a6be6">

## 빠르게 두 번 클릭하면 잘못된 결과가 나온다

<img width="735" alt="스크린샷 2023-10-28 오후 4 32 33" src="https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/assets/62797441/f3a8f34e-fc5e-4c1d-b11b-4798bad29cc3">

타임라인에 클릭 핸들러가 어디에 나타나는지에 따라 액션의 순서가 달라진다. 각 단계가 섞이는 것을 막을 수 없다. 어떤 경우에는 이런 방식으로 섞이고 어떤 경우에는 또 다른 방법으로 실행된다.

위 경우에는 비교적 짧지만 실행 가능한 순서가 10개나 된다. 실제 경우에는 가능한 순서가 100, 1000, 10000개가 될 수도 있다. 코드가 잘 동작한다는 것을 보장하기 위한 다른 방법이 필요하다.

## 자원을 공유하는 타임라인은 문제가 생길 수 있다

### 공유하는 자원을 없애 문제를 해결할 수 있다

전역 변수에 접근하기 때문이다. -> 지역 변수로 바꾸자.

### 지역변수로 바꾸기

<img width="584" alt="스크린샷 2023-10-28 오후 4 38 04" src="https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/assets/62797441/0eb76dce-088c-4f3e-bfa9-16e9b7d028f7">

### 전역변수를 인자로 바꾸기

#### 1. 암묵적 인자 확인하기

<img width="619" alt="스크린샷 2023-10-28 오후 4 39 54" src="https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/assets/62797441/f720e341-278c-4433-99f7-f820c8b13800">

#### 2. 암묵적 입력을 인자로 바꾸기

<img width="618" alt="스크린샷 2023-10-28 오후 4 40 00" src="https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/assets/62797441/e8ea49cf-cdb7-4f58-8630-13bf1abb10c6">

#### DOM 자원을 여전히 공유하고 있어 버그가 남아 있다

<img width="322" alt="스크린샷 2023-10-28 오후 4 40 43" src="https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/assets/62797441/106653d1-72d0-486a-bf9f-9eb431a75e52">

## 재사용하기 더 좋은 코드로 만들기

DOM을 바꾸는 것은 암묵적 출력이다. 하지만 비동기 콜백이 완료되어야 한다. 따라서 리턴값으로는 전달할 수 없다. -> 콜백을 만들자.

값을 리턴할 수 없기에 콜백 함수로 전달해야 한다. **함수 본문을 콜백으로 바꾸기** 리팩터링을 사용해 보자.

<img width="692" alt="스크린샷 2023-10-28 오후 4 44 39" src="https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/assets/62797441/0273697e-b156-49e6-a26e-56f245064710">

## 원칙: 비동기 호출에서 명시적인 출력을 위해 리턴값 대신 콜백을 사용할 수 있다

> **동기 함수**<br/>- 호출하는 곳에서 리턴값을 사용할 수 있다.<br/>- 액션을 빼내기 위해 액션을 부르는 곳은 리턴값으로 바꾸고 액션에 리턴값을 인자로 전달한다.

> **비동기 함수**<br/>- 미래에 어떤 시점에 콜백을 통해 결과를 받는다.<br/>- 액션을 빼내기 위해 액션을 부르는 곳은 콜백을 부르도록 바꾸고 액션을 콜백으로 전달한다.

비동기 호출에서 결괏값을 리턴값으로 줄 수 없다. 비동기 호출은 바로 리턴이 되지만 결괏값은 콜백이 호출되어야 얻을 수 있기 때문이다. 동기화된 함수와 같이 일반적인 방법으로 결과를 받을 수 없다.

비동기 호출에서 결과를 받을 수 있는 방법은 콜백을 사용하는 것이다.
 결과가 준비되었을 때 결과를 인자에 넣어 콜백을 호출한다. JS에서 일반적인 비동기 프로그래밍 방법이다.

함수형 프로그래밍을 할 때 이 기술은 비동기 함수에서 액션을 빼낼 때 사용할 수 있다. 동기화된 함수에서 액션을 빼낼 때 액션을 호출하는 대신 액션에 넘기는 인잣값을 리턴했다. 그리고 호출하는 곳에서 리턴값을 받아 액션을 호출했다. 비동기 함수에서는 리턴값 대신 콜백을 사용한다.

<img width="627" alt="스크린샷 2023-10-28 오후 4 50 02" src="https://github.com/FrontendStudySeoul/SsogSsogFunctionalCoding/assets/62797441/92299ed3-f61e-4668-a0a0-53da813713d6">

## 요점 정리

- 타임라인은 동시에 실행될 수 있는 순차적 액션이다. 코드가 순서대로 실행되는지 동시에 실행되는지 알 수 있다.
- 현대 소프트웨어는 여러 타임라인에서 실행된다. 서로 다른 컴퓨터나 스레드, 프로세스, 비동기 호출과 같은 것이 있다면 새로운 타임라인을 추가한다.
- 서로 다른 타임라인에 있는 액션은 끼어들 수 있어서 여러 개의 실행 가능한 순서가 생긴다. 실행 가능한 순서가 많으면 코드가 항상 올바른 결과를 내는지 알기 어렵다.
- 타임라인 다이어그램은 코드가 순서대로 실행되는지 동시에 실행되는지를 알려준다. 타임라인 다이어그램으로 서로 영향을 주는 부분이 어떤 부분인지 알 수 있다.
- 언어에서 지원하는 스레드 모델을 이해하느 것은 중요하다. 분산 시스템에서 어떤 부분이 순서대로 실행되고 어떤 부분이 동시에 실행되는지 이해하는 것이 중요하다.
- 자원을 공유하는 부분은 버그가 발생하기 쉽다. 공유 자원을 확인하고 없애면 코드가 더 좋아진다.
- 자원을 공유하지 않는 타임라인은 독립적으로 이해하고 실행할 수 있다. 따라서 함께 생각해야 할 내용이 줄어든다.
