## 자바스크립트의 읽기 동작
- 불변성 유지하기라는 주제를 갖고 있는 6장은 동작을 읽기, 쓰기 또는 글자로 분류하기 해서 읽기와 쓰기 동작으로 나누고 있음
- 자바스크립트 같은 경우에 기체랑 대열을 사용하면 패스 바이 레퍼런스 방식을 사용하기 때문에 외부에서 값이 수정되거나 함수 내부에서 외부에 영향을 미칠 수 있게 때문에 박히는 값이 어디서 사용될 지 모르기 때문에 바뀌지 않도록 원칙이 필요함
- 카피온 라이트의 세 가지 원칙은 첫 번째로 코드에서는 전달받은 어레이를 복사본을 슬라이스를 통해서 만들고 두 번째로는 복사본을 변경을 한 다음에 해당 복사본을 리턴해주면 됨
- 펑션 함수, 에드 엘리먼트 라스트 함수 같은 경우에는 스프레드 표기법을 사용해서 더 간결하게 작성할 수 있음
- 데이터를 바꾸지 않고 뉴 어레이라는 정보를 반환하기 때문에 읽기 동작이라고 할 수 있음
- 함수형 프로그래밍 언어 클로저나 엘릭서 같은 거를 말하고 있었는데 그 언어에는 빠른 구현체가 있다고 함
- 
<br>

## 오브젝트 어사인과 스프레드의 성능상 차이점
- 오브젝트 어사인이랑 스프레드의 성능상 차이점에 대해서 알고 있는지 물음
- 의미 있게 차이가 많이 나지 않을 것 같음
- 무의미하지 않음
- 의미 있는 정도는 아님
- 추측인 거라 모름

## 방어적 복사
- 방어적 복사를 하는 코드를 분리를 해서 새로운 함수로 리스토링하는 것까지 책에서 소개를 해 주고 있음
- 방어적 복사는 신뢰할 수 없는 코드와 데이터 상호작용을 할 때 사용을 함
- 안전화 코드 경계에서 데이터를 주고받을 때 카피 마이트 같은 경우는 얕은 방식을 사용한다면 방어적 복사 같은 경우는 깊은 복사 방식을 진행을 함

## 카피 라이팅 패턴
- 카피 라이팅 패턴이랑 기픈 복사를 적절하게 사용을 해서 할 수 있을지에 대한 구조나 이런 거에 대해서도 얘기를 해서 같이 진행하면 좋을 것 같음
- 자변성을 보장하지만 결국에는 비용이 비싸기 때문에 어느 정도의 트랙 오프가 있다고 생각을 함
- 중간선을 잘 지켜서 하면 좋을 것 같음

## 계층형 설계
- 계층형 설계는 레이어들이 나뉘어져 있는데 바로 아래 계층의 함수로 지금 계층의 함수를 만드는 방법임
- 계층형 설계는 소프트웨어를 계층으로 구성하는 기술이고 각 계층을 정확히 구분하는 것은 어렵고 잘 구분하려면 다양한 변수 찾고 찾은 거를 어떻게 가지고 어떻게 해야 되는지 알아야 된다는 점이 있음
- 계층형 설계라는 것도 정답은 없고 감각을 키우기 위해서 입력이랑 출력을 알아야 됨
- 함수 본문이 있고 계층 구조가 있고 함수 시그니처가 있음
- 각 항목에 어떤 것들이 있는지 일단은 입력 사항들을 알아야 되고 출력에서도 구현이 어떻게 되어 있고 어떤 곳을 또 변경을 할 수 있고 조직화라는 거는 함수를 어떻게 구성을 할 건지 그런 것들을 알고 있어야 됨

## 함수의 계층
- 함수가 모두 비슷한 계층이 있다는 것을 의미를 하게 되고 모두 비슷한 계층이 있다면 직접 구현했다고 볼 수 있음
- 호출 그래프를 통해 시스템 계층이 어떻게 구성돼 있는지 전체적으로 보는 데 도움이 됨
- 복잡한 정보는 한 번에 볼 수가 없다는 점이 있고 계층형으로 나누게 되면 설계 감각을 키우는 데 중요한 역할을 함

## 다이어그램의 장점
- 다이어그램은 함수가 호출하는 것을 있는 그대로 표현한 것이라서 함수를 어떤 계층에 놓을지 바로 알 수가 있음
- 계층형 설계를 하기 위한 방법 중 하나임
- 계층 줌 레벨은 특정 계층의 구현을 보는 것임

## 함수의 구체화 수준
- 다양한 계층을 넘나드는 거는 같은 구체화 수준이 아니라는 증거가 됨
- 함수를 일반적인 함수로 만들어서 재활용을 할 수가 있음
- 함수 줌 레벨을 사용하면 함수 하나가 가진 화살표를 비교를 할 수가 있음

## 계층형 설계의 장점
- 계층형 설계는 특정 구체화 단계에만 집중할 수 있도록 도와줌
- 호출 그래프는 구체화 단계에 대한 풍부한 단서를 보여주고 함수를 추출하면 더 일반적인 함수로 만들어서 직접 구현 패턴을 이용하게 됨
- 직접 구현 패턴을 적용하는 방법은 더 구체적인 내용을 다루지 않도록 함수를 일반 함수로 계속 추상화를 시키는 것임

## 리팩터링의 개념
- 네임의 존재를 없애려면 함수를 어떻게 구현하면 좋을지 질문함
- 네임을 비교해서 2루를 리턴 없는 함수를 두 번째 인자로 넘기면 인덱스 오브 아이템에서는 받은 콜백 함수를 실행시켜가지고 트루인지만 판단해서 인덱스를 리턴하는 함수로 고치면은 인덱스 오브 아이템이 객체 카트 안에 있는 아이템의 구조나 네임의 존재를 몰라도 그냥 받은 콜백 함수가 트루인지 판단하는 그런 계층이 조금 아래인 함수로 구현을 할 수 있을 것 같음
- 계층형 설계가 아닌 직접 구현 패턴을 적용한 코드처럼 보이게 만드는 것이 리팩터링임

## 함수의 정의
- 함수에 접보문이 두 개 있다고 했을 때 위에 거 읽다 보니까 아니었어 두 번째 문 막 읽고 막 그랬던 경험이 있었음
- 저런 식으로 해놔야 나중에 유지보수 하기에도 좋을 것 같음
- 일반 함수로 많이 만들어라가 최대한 계산하는 함수로 만들어라라는 말과 비슷함

## 추상화 벽의 개념
- 장바구니 데이터 구조를 이용한 함수들을 모두 고쳐야 함
- 추상화 벽은 필요하지 않은 것들을 무시할 수 있도록 간접적인 단계를 의미함
- 추상화 벽을 사용하는 이유는 코드를 쓰기 쉽게 만들 수 있고 생산적인 코드를 만들 수 있음
- 추상화 벽을 사용하는 방법은 상위 계층에 올려두는 것임

## 책을 읽고 느낀 점
- 책을 읽으면서 메시지는 처음에 했던 말을 계속하는 것 같음
- 직접 구현해보면 더 많이 와닿겠다는 생각이 듦
- 책에서 나온 내용을 공유하고 질문에 답변함
