# 계층형 설계 1
계층형 설계: 바로 아래 계층의 함수로 지금 계층의 함수를 만드는 방법

살펴볼 내용
- SW 설계에 대한 실용적인 정의 소개
- 계층형 설게를 이해하고 어떤 도움이 되는지
- 깨끗한 코드를 만들기 위해 함수 추출 방법
- 계층을 나눠서 SW를 설계하면 왜 더 나은 생각을 할 수 있는지

> __SW 설계__<br/>코드를 만들고, 테스트하고, 유지보수하기 쉬운 프로그래밍 방법을 선택하기 위해 미적 감각을 사용하는 것.

## 계층형 설계
<img width="600" alt="스크린샷 2023-09-17 오전 4 46 53" src="https://github.com/ESC-CoM/esc-front-end/assets/62797441/b8ce107d-5afc-42ac-ae21-354b49e63d82">

- SW를 계층으로 구성하는 기술.
- 각 계층을 정확히 구분하는 것은 어려움. 잘 구분하려면 구분하기 위한 다양한 변수를 찾고 찾은 것을 가지고 어떻게 해야 하는지 알아야 함.

## 설계 감각 키우기
### 계층형 설계 감각을 키우기 위한 입력
<img width="600" alt="스크린샷 2023-09-17 오전 4 48 50" src="https://github.com/ESC-CoM/esc-front-end/assets/62797441/03bd113c-49c2-4036-b0df-533adddcad03">


### 계층형 설계 감각을 키우기 위한 출력
<img width="600" alt="스크린샷 2023-09-17 오전 4 49 45" src="https://github.com/ESC-CoM/esc-front-end/assets/62797441/ecdb370f-0b21-4255-bca5-99797b798bfc">

## 계층형 설계 패턴
### 패턴 1: 직접 구현
너무 구체적이라면 코드에서 나는 냄새

### 패턴 2: 추상화 벽
호출 그래프에 어떤 계층은 중요한 세부 구현을 감추고 인터페이스를 제공함. 인터페이스를 사용하여 코드를 만들면 높은 차원으로 생각할 수 있음.

### 패턴 3: 작은 인터페이스
비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성하는 것이 좋음. 다른 동작도 직간접적으로 최소한의 인터페이스를 유지하면서 정의해야 함.

### 패턴 4: 편리한 계층
- 개발자의 요구를 만족시키면서 비즈니스 문제를 잘 풀 수 있어야 함.
- SW를 더 빠르고 고품질로 제공하는 데 도움이 되는 계층에 시간을 투자해야 한다.
- 그냥 좋아서 계층을 추가하면 안 된다.
- 코드와 코드가 속한 추상화 계층은 작업할 때 편리해야 한다.

## 패턴 1: 직접 구현
```js
function freeTieClip(cart) {
  var hasTie = false
  var hasTieClip = false;
  for(var i = 0; i < cart.length; i++) {
    var item = cart[i];
    if(item.name === "tie")
      hasTie = true;
    if(item.name === "tie clip")
      hasTieClip = true;
  }
  if(hasTie && !hasTieClip) {
    var tieClip = make_item("tie clip", 0);
    return add_item(cart, tieClip);
  }
  return cart;
}
```

### 문제점
- 어렵지 않지만 많은 기능이 있음.(장바구니를 돌면서 항목을 체크하고 무엇인가를 결정함.)
- 제대로 설계하지 않고 그냥 기능을 추가함.(설계 원칙이 없음)
- 직접 구현 패턴을 따르지 않고 있음.(함수가 알아야 할 필요가 없는 구체적인 내용을 담고 있음.)

### 제품이 있는지 확인하는 함수 개선
```js
for(var i = 0; i < cart.length; i++) {
  var item = cart[i];
  if(item.name === "tie")
    hasTie = true;
  if(item.name === "tie clip")
    hasTieClip = true;
}
```
위 코드를 `isInCart`로 분리

```js
function freeTieClip(cart) {
  var hasTie = isInCart(cart, "tie");
  var hasTieClip = isInCart(cart, "tie clip");
  if(hasTie && !hasTieClip) {
    var tieClip = make_item("tie clip", 0);
    return add_item(cart, tieClip);
  }
  return cart;
}
```

### 호출 그래프를 만들어 함수 호출 시각화
<img width="500" alt="스크린샷 2023-09-17 오후 12 46 33" src="https://github.com/ESC-CoM/esc-front-end/assets/62797441/3f8c12ee-cd8c-4e8a-9838-5512eba9b1f2">

- 언어 기능(배열 인덱스 참조 등)과 직접 만든 함수는 추상화 수준이 다름.
- 언어 기능이 더 낮은 추상화 단계

-> 한 함수에서 서로 다른 추상화 단계를 사용하면 코드가 명확하지 않아 읽기 어려움.

### 직접 구현 패턴을 사용하면 비슷한 추상화 계층에 있는 함수 호출
서로 다른 추상화 단계에 있는 기능을 사용하면 직접 구현 패턴이 아님.

<img width="400" alt="스크린샷 2023-09-17 오후 12 50 02" src="https://github.com/ESC-CoM/esc-front-end/assets/62797441/752320fb-9d00-4455-9cb4-c18f29bbe95a">

- freeTieClip은 장바구니가 배열로 되어 있는지 몰라도 된다.
- 또, freeTieClip이 사용하는 모든 함수는 장바구니가 배열인지 몰라도 된다.
- 장바구니가 배열인지 몰라도 된다는 것은 함수가 모두 비슷한 계층에 있다는 것을 의미
- 함수가 모두 비슷한 계층에 있다면 직접 구현했다고 할 수 있음.

### 질문 목록
1. 호출 그래프가 정말 필요할까? 그냥 코드를 봐도 문제를 알 수 있는 것 같다.
- 만약 함수를 더 추가하면 더 많은 계층이 생길 수 있다.
- 계층이 많으면 호출 그래프를 통해 시스템 계층이 어떻게 구성되어 있는지 전체적으로 보는 데 도움이 된다.
- 복잡한 정보는 한 번에 볼 수 없는 작은 코드로는 얻을 수 없다.
- 이러한 계층 구조는 설계 감각을 키우는 데 중요한 역할을 한다.
2. 모든 다이어그램을 다 그려야 하나요?
- 대부분은 그리지 않아도 된다. 장점을 알았다면 머릿속에서 그려볼 수 잇다.
- 화이트보드에 그려 공유할 수 있다면 좋은 커뮤니케이션 도구가 된다.
- 설계에 대해 논의를 하다 보면 추상적인 이야기가 될 수 있다.
- 다이어그램이 있다면 구체적인 것을 보며 논의할 수 있다.
3. 앞에서 그린 계층이 정답이고 모두가 동의할 수 있는 객관적인 것인가요?
- 계층형 설계는 각자의 관점으로 사람들이 사용하면서 습득한 것.
- 계층형 설계는 코드 구조를 자세히 볼 수 있는 고글
- 고글을 쓰고 코드를 보면 재사용, 테스트, 유지보수하기 쉬운 코드를 만들 수 있는 방법을 찾을 수 있음.
- 도움이 되지 않는다면 고글을 벗으면 됨.
- 다른 사람의 고글을 봤다면 교환해볼 것.
4. 내가 그린 것과 예제가 다를 때
- 더 구체적으로 보거나 더 높은 단계로 보는 것은 우리의 자유

### 여기까지 정리
<img width="669" alt="스크린샷 2023-09-17 오후 12 56 00" src="https://github.com/ESC-CoM/esc-front-end/assets/62797441/4ef72c6b-17a9-48ad-9ca2-75596be8c167">

- 직접 구현 패턴을 통해 함수의 추상화 단계를 비슷하게 맞추고 상위 단계 함수에서는 바로 하위 단계의 함수만 쓰도록 프로그래밍하면 하위 함수의 구현에 신경쓰지 않아도 된다.
  - 각 계층은 추상화 수준이 달라 구체적인 내용은 신경 쓰지 않아도 된다.
- 같은 단계에 있는 함수는 같은 목적을 가져야 한다.
  - 같은 박스를 가리킨다는 것은 같은 계층에 있어도 좋다는 정보이다.
- 다이어그램은 함수가 호출하는 것을 있는 그대로 표현한 것이기 때문에 함수를 어떤 계층에 놓을지 바로 알 수 있다.
  - 코드를 높은 차원에서 볼 수 있는 좋은 도구
  - 단순히 코드를 높은 차원에서 보기 위한 것이 아니라 계층형 설계를 하기 위한 방법 중 하나

## 3단계 줌 레벨
계층형 설계의 영역
1. 계층 사이의 상호 관계 -> 전역 줌 레벨
2. 특정 계층의 구현 -> 계층 줌 레벨
3. 특정 함수의 구현 -> 함수 줌 레벨

<img width="600" alt="스크린샷 2023-09-17 오후 2 12 08" src="https://github.com/ESC-CoM/esc-front-end/assets/62797441/5b51627e-65be-4a91-aec1-5170d9cea290">

### 계층 줌 레벨로 보면 함수가 가리키는 화살표를 계층 간에 비교할 수 있음
계층에 집중해 보면 계층에 있는 모든 함수와 직접 호출하는 함수를 모두 볼 수 있음.
- 화살표가 복잡해 보이는 것은 숨길 수 없음.
- 복잡한 이유는 코드가 정돈되어 있지 않기 때문

직접 구현 패턴을 사용하면 모든 화살표가 같은 길이를 가져야 함.
- 어떤 화살표는 한 계층 길이, 어떤 화살표는 세 계층 길이 -> 이렇게 다양한 계층을 넘나드는 것은 같은 구체화 수준이 아니라는 증거

### 함수 줌 레벨을 사용하면 함수 하나가 가진 화살표를 비교할 수 있음.
<img width="600" alt="스크린샷 2023-09-17 오후 2 14 56" src="https://github.com/ESC-CoM/esc-front-end/assets/62797441/a5c4e310-b9cc-4698-a3e7-199ef4e26451">

함수가 모두 같은 길이의 화살표를 가지지 않기 때문에 직접 구현 패턴이 아님.
- 가장 일반적인 방법은 중간에 함수를 두는 것.
- 언어 기능을 사용하는 긴 화살표를 줄여야 함.
  <img width="600" alt="스크린샷 2023-09-17 오후 2 16 00" src="https://github.com/ESC-CoM/esc-front-end/assets/62797441/7fdc5c31-9a63-432e-8d2f-43fadc5f0637">

- indexOfItem vs removeItems

  <img width="323" alt="스크린샷 2023-09-17 오후 2 29 49" src="https://github.com/ESC-CoM/esc-front-end/assets/62797441/fa50be8b-502c-4d7f-a389-ee46eec89921">
  
  - 엄밀히 말하면 indexOfItem이 더 위에 위치함. 배열에 있는 항목이 name 속성을 가지고 있다는 것을 알아야 하기 때문
  - 반면 removeItems는 배열에 들어 있는 항목이 어떻게 생겼는지 몰라도 됨.

### 질문
화살표 길이를 줄이려다 보니 화살표 개수가 더 많아져서 직접 구현인 것 같지 않고 더 복잡해진 것 같다.
- 앞서 했던 것들로 코드나 호출 그래프에서 설계를 개선할 수 있는 것들을 찾을 수 있다.
- 결국 좋은 설게를 하기 위해서는 지속적인 탐구와 직관이 필요하다.
- 설계는 어렵고 개발자들도 서로 동의하지 않을 수도 있고, 상황에 따라 좋은 설계의 기준이 달라지기도 한다.
- 그래서 설계에 대해 이야기할 때는 같은 용어를 사용하는 것이 중요하고 상황을 고려해서 평가해야 한다.

## 직접 구현 패턴 리뷰
1. 직접 구현한 코드는 한 단게의 구체화 수준에 관한 문제만 해결한다.
2. 게층형 설계는 특정 구체화 단계에 집중할 수 있게 도와준다.
- 코드에 있는 다양한 단서를 통해 구체화 수준에 집중하다 보면 설계 감각을 키울 수 있다.
3. 호출 그래프는 구체화 단계에 대한 풍부한 단서를 보여준다.
- 호출 그래프는 함수가 서로 어떻게 연결되어 있는지 보여준다.
- 함수 시그니처와 본문, 호출 그래프와 같은 다양한 단서를 가지고 직접 코드 패턴을 적용할 수 있다.
4. 함수를 추출하면 더 일반적인 함수로 만들 수 있다.
- 직접 구현 패턴을 적용하는 방법의 하나는 함수가 더 구체적인 내용을 다루지 않도록 함수를 일반 함수로 빼내는 것.
- 일반적인 함수는 보통 구체적인 내용을 하나만 다루기 때문에 테스트하기 쉬움.
5. 일반적인 함수가 많을수록 재사용하기 좋음.
- 구현을 명확하기 하기 위해 일반적인 함수를 빼내는 것.
- 일반적인 함수는 구체적인 함수보다 더 많은 곳에서 쓸 수 있음.
- 사용할 곳을 따로 찾지 않아도 재사용할 수 있는 곳을 발견할 수 있음.
- 함수 이름은 의도를 알려줌. 비슷한 목적의 이름을 가진 함수를 함께 묶을 수 있음.
6. 복잡성을 감추지 않음.
- 직접 구현 패턴을 적용한 코드처럼 보이게 만드는 것은 쉽다. 명확하지 않은 코드를 감추기 위해 도우미 함수를 만들면 된다. -> 계층형 설계가 아님.
- 계층형 설계에서 모든 계층은 바로 아래 계층에 의존해야 함.
- 복잡한 코드를 같은 계층으로 옮기면 안됨. 더 추상화된 일반적인 함수를 만들어 SW에 직접 구현 패턴을 적용해야 함.
